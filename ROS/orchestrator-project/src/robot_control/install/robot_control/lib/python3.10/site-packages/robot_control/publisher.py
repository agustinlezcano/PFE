import rclpy
from rclpy.node import Node
from .main import *
from .limits_validator import LimitsValidator
from .trajectory_reader import CSVTrajectoryReader
from .user_interface import UserInterface
from typing import Optional, Dict

from std_msgs.msg import String
from geometry_msgs.msg import Point
from std_msgs.msg import Bool
import time
from extra_interfaces.msg import Trama
from enum import Enum

class RobotState(Enum):
    '''
    States of the robot for control flow.
    '''
    IDLE = 0
    RUNNING = 1
    EMERGENCY_STOP = 2
    BLOCKED = 3
    STOPPED = 4


class MinimalPublisher(Node):

    def __init__(self, enable_ui: bool = False):
        super().__init__('minimal_publisher')
        
        # Inicializar validador de límites y reader de trayectorias
        self.limits_validator = LimitsValidator()
        self.trajectory_reader = CSVTrajectoryReader(self.limits_validator)
        
        # Flag de parada de emergencia
        self.emergency_stop = False

        # Flag de Homing
        self.homing = False
        
        # Flag para solicitar ángulos actuales
        self.request_current_angles = False

        # Estado inicial del robot
        self.state = RobotState.IDLE
        
        # Publishers
        self.homing_publisher_ = self.create_publisher(Bool, '/microROS/homing', 10)
        self.current_angles_publisher_ = self.create_publisher(Bool, '/microROS/request_current_angles', 10)
        self.cmd_publisher_ = self.create_publisher(Point, '/microROS/cmd', 10)
        self.inv_publisher_ = self.create_publisher(Point, '/microROS/inverse', 10)
        self.estop_publisher_ = self.create_publisher(Bool, '/microROS/emergency_stop', 10) # TODO: make callback
        
        # Publisher for trajectory planning node
        # TODO: use this when receiving point from Camera node and sending to Trajectory Planner node
        # Currently not used, but will be needed to send objectives to the trajectory planner node
        self.trajectory_planning_publisher = self.create_publisher(Point, 'ROS/trajectory_planning', 10)
        
        # Subscribers para tópicos de UI
        self.ui_cmd_subscriber = self.create_subscription(
            Point,
            '/robot_ui/cmd',
            self.ui_cmd_callback,
            10)
        
        self.ui_invkin_subscriber = self.create_subscription(
            Point,
            '/robot_ui/invkin',
            self.ui_invkin_callback,
            10)
        
        self.ui_homing_subscriber = self.create_subscription(
            Bool,
            '/robot_ui/homing',
            self.ui_homing_callback,
            10)
        
        self.ui_estop_subscriber = self.create_subscription(
            Bool,
            '/robot_ui/emergency_stop',
            self.ui_estop_callback,
            10)
        
        self.ui_csv_subscriber = self.create_subscription(
            String,
            '/robot_ui/load_csv',
            self.ui_csv_callback,
            10)
        
        self.ui_request_angles_subscriber = self.create_subscription(
            Bool,
            '/robot_ui/request_current_angles',
            self.ui_request_angles_callback,
            10)
        
        # Subscribers para tópicos de micro-ROS
        self.subscriber = self.create_subscription(
            String,
            '/microROS/string_publisher',
            self.subscriber_callback,
            10)

        # TODO: delete -> now used to test timer publishing
        self.in_subscriber = self.create_subscription(
            String,
            '/microROS/tim_publisher',
            self.in_subscriber_callback,
            10)

        # TODO: delete
        self.cmd_string_subscriber = self.create_subscription(
            String,
            '/microROS/cmd_publisher',
            self.cmd_subscriber_callback,
            10)
        
        # Subscriber for planned trajectory path from trajectory planner node
        self.planner_path_subscriber = self.create_subscription(
            Point,
            'planner/path',
            self.planner_path_callback,
            10)

        timer_period = 0.5  # seconds [0.01] -- Usado en timers [TEST]
        # self.sArray, self.sdArray, self.sddArray, self.t = initialize_and_generate_trajectory()
        self.doHoming()

        self.i = 0
        # For use in Point Array
        self.x = 0.0
        self.y = 0.0
        self.z = 0.0
        # For use in Joint States and Direct Commands
        self.q1 = 0.0
        self.q2 = 0.0
        self.q3 = 0.0
        
        self.get_logger().info("Publisher node initialized. Waiting for UI node commands...")

        # Initialize optional in-process UI when requested
        if enable_ui:
            try:
                self.user_interface = UserInterface(self)
                self.user_interface.start()
            except Exception as e:
                self.get_logger().error(f'Failed to start UserInterface: {e}')
                self.user_interface = None
        else:
            self.user_interface = None

    def inv_timer_callback(self):

        msg = Point()
        msg.x = self.x
        msg.y = self.y
        msg.z = self.z

        self.inv_publisher_.publish(msg)
        self.get_logger().info(f'Publicado Inv K: x={msg.x}, y={msg.y}, z={msg.z}')

        # Actualizo valores de ejemplo
        self.x += 0.1
        self.y += 0.1
        self.z += 0.1

    def subscriber_callback(self, msg):
        self.get_logger().info('I heard: "%s"' % msg.data)
        # add logic to handle the received message if needed
    
    # TODO: use this in when receive objective from camera
    def array_to_point(self, value) -> Point:
        """
        Convert array or Point value to Point message format.
        
        Args:
            value: Can be a Point message, list, tuple, or numpy array with [x, y, z] values
            
        Returns:
            Point message object
            
        Raises:
            ValueError: If the input format is not supported or doesn't have 3 elements
            
        NOTE: If the received parameter is different than array format (e.g., different
        axes order, different number of elements, or non-numeric values), this method
        will raise an error. Ensure the input data structure matches the expected format:
        [x, y, z] or Point(x, y, z).
        """
        point_msg = Point()
        
        # If already a Point message, return as is
        if isinstance(value, Point):
            return value
        
        # If it's an array-like (list, tuple, numpy array)
        if hasattr(value, '__len__') and hasattr(value, '__getitem__'):
            if len(value) != 3:
                raise ValueError(f"Expected array with 3 elements [x, y, z], got {len(value)} elements")
            try:
                point_msg.x = float(value[0])
                point_msg.y = float(value[1])
                point_msg.z = float(value[2])
                return point_msg
            except (TypeError, ValueError) as e:
                raise ValueError(f"Could not convert array elements to float: {e}")
        
        raise ValueError(f"Unsupported value type: {type(value)}. Expected Point, list, tuple, or numpy array")
    
    def planner_path_callback(self, msg: Point):
        """
        Process trajectory points received from the trajectory planner node.
        
        This callback receives individual waypoints of the planned path and can be used
        to execute commands, log progress, or update the robot state.
        """
        self.get_logger().debug(f'Received planned path point: x={msg.x:.4f}, y={msg.y:.4f}, z={msg.z:.4f}')
        # TODO: Implement logic to handle the planned trajectory point
        # For example: execute the point, update robot position, etc.
        self.doCmd(msg.x, msg.y, msg.z)

    def load_objects_list(self, filepath: str) -> bool:
        """Carga la lista de objetos a recoger."""
        success, message = self.objects_reader.read_objects_list(filepath)
        if success:
            self.get_logger().info(f'Lista de objetos cargada: {message}')
            if self.state == RobotState.IDLE:
                self.request_next_object()
            return True
        else:
            self.get_logger().error(f'Error cargando lista de objetos: {message}')
            return False

    def request_next_object(self):
        """
        Solicita el siguiente objeto a recoger del servidor de visión artificial.
        
        NOTE: Esta parte será implementada cuando se conecte con el servidor de visión.
        El flujo debería ser:
        1. Obtener siguiente objeto de la lista
        2. Conectar al servidor de visión por socket (puerto a definir)
        3. Enviar solicitud con ID del objeto
        4. Esperar respuesta con coordenadas (x, y, z)
        """
        # TODO: Conectar con servidor de visión por socket
        # TODO: Implementar handshake y protocolo de comunicación
        # TODO: Definir formato de mensaje (JSON, protobuf, etc.)
        
        next_obj = self.objects_reader.get_next_object()
        if next_obj is None:
            self.get_logger().info('Lista de objetos finalizada')
            self.state = RobotState.IDLE
            return
        
        self.current_object = next_obj
        self.state = RobotState.BLOCKED
        self.get_logger().info(f'Solicitando objeto: {next_obj["name"]} (ID: {next_obj["id"]})')
        
        # TODO: Implementar envío por socket al servidor de visión
        # socket_client.send(f"REQUEST:{next_obj['id']}")
        # response = socket_client.receive()  # Espera respuesta con coordenadas [x, y, z]
        # self.process_vision_response(response)

    def process_vision_response(self, response) -> bool:
        """
        Procesa la respuesta del servidor de visión artificial.
        
        Args:
            response: Respuesta con coordenadas del objeto (puede ser array, JSON string, etc.)
            
        Returns:
            True si se procesó correctamente, False en caso de error
        """
        try:
            # Convertir respuesta a Point (puede venir en diferentes formatos)
            point_msg = self.array_to_point(response)
            
            self.get_logger().info(f'Respuesta de visión: x={point_msg.x:.4f}, y={point_msg.y:.4f}, z={point_msg.z:.4f}')
            
            # Enviar comando de cinemática inversa al trajectory planner
            self.trajectory_planning_publisher.publish(point_msg)
            
            # Cambiar a estado BLOCKED esperando respuesta del planner
            self.state = RobotState.BLOCKED
            self.get_logger().info(f'Objetivo enviado al trajectory planner')
            
            return True
        
        except Exception as e:
            self.get_logger().error(f'Error procesando respuesta de visión: {e}')
            return False

    def microros_feedback_callback(self, msg):
        """
        Callback para recibir feedback de microROS.
        
        El mensaje debería contener:
        - angleDone: bool (True si completó movimiento)
        - electroIman: bool (True si electroimán está activo)
        
        Cuando angleDone=True y electroIman=False, significa que el movimiento
        terminó y puede pasar al siguiente objeto.
        """
        # TODO: Reemplazar con mensaje custom adecuado
        # Por ahora usando Point como placeholder
        
        self.get_logger().debug(f'Feedback recibido: x={msg.x}, y={msg.y}, z={msg.z}')
        
        # TODO: Implementar lógica cuando se tenga el mensaje custom
        # if msg.angleDone and not msg.electroIman:
        #     self.state = RobotState.IDLE
        #     self.current_object = None
        #     self.request_next_object()
        # elif msg.angleDone and msg.electroIman:
        #     self.get_logger().info(f'Objeto capturado: {self.current_object["name"]}')

    def doHoming(self):
        do_homing = Bool()
        self.homing = True
        do_homing.data = self.homing    #Asignar flag de homing a mensaje
        self.homing_publisher_.publish(do_homing)
        self.get_logger().info(f'Publicado homing = {do_homing.data}')
        self.homing = False

    
    def doRequestCurrentAngles(self):
        """Solicita los ángulos actuales de los motores."""
        request_msg = Bool()
        self.request_current_angles = True
        request_msg.data = self.request_current_angles
        self.current_angles_publisher_.publish(request_msg)
        self.get_logger().info(f'Publicado solicitud de ángulos actuales = {request_msg.data}')
        self.request_current_angles = False

    def doCmd(self,q1: float = None, q2: float = None, q3: float = None):
        """Publica comando directo con coordenadas articulares."""
        # Validar coordenadas articulares si se proporcionan
        if q1 is not None and q2 is not None and q3 is not None:
            valid, msg = self.limits_validator.validate_joint_position(q1, q2, q3)
            if not valid:
                self.get_logger().error(f'Joint validation error: {msg}')
                return
            # Actualizar variables articulares
            self.q1 = q1
            self.q2 = q2
            self.q3 = q3
        
            # Publicar comando
            cmd_msg = Point()
            cmd_msg.x = q1
            cmd_msg.y = q2
            cmd_msg.z = q3
            self.cmd_publisher_.publish(cmd_msg)  # Usa el mismo publisher que los timers
        
            if q1 is not None:
                log_msg = f'Publicado CMD: q1={q1:.4f}, q2={q2:.4f}, q3={q3:.4f}'
                self.get_logger().info(log_msg)
        else:
            self.get_logger().error('doCmd requiere q1, q2, q3 como argumentos.')

    def doInvKin(self, x, y, z):
        """Publica comando de cinemática inversa con validación de límites."""
        # Validar coordenadas Cartesianas
        valid, msg = self.limits_validator.validate_cartesian_position(x, y, z)
        if not valid:
            self.get_logger().error(f'InvKin validation error: {msg}')
            return
        
        # Publicar comando de cinemática inversa
        cmd_msg = Point()
        cmd_msg.x = x
        cmd_msg.y = y
        cmd_msg.z = z
        self.inv_publisher_.publish(cmd_msg)
        
        log_msg = f'Publicado INV: x={cmd_msg.x}, y={cmd_msg.y}, z={cmd_msg.z}'
        self.get_logger().info(log_msg)
    
    # ======================== UI Callbacks ========================
    
    def ui_cmd_callback(self, msg: Point):
        """Procesa comandos de movimiento directo desde el nodo UI."""
        if self.emergency_stop:
            self.get_logger().warn('E-Stop activado: Comando bloqueado')
            return
        self.doCmd(msg.x, msg.y, msg.z)
    
    def ui_invkin_callback(self, msg: Point):
        """Procesa comandos de cinemática inversa desde el nodo UI."""
        if self.emergency_stop:
            self.get_logger().warn('E-Stop activado: Comando bloqueado')
            return
        self.doInvKin(msg.x, msg.y, msg.z)
    
    def ui_homing_callback(self, msg: Bool):
        """Procesa comando de homing desde el nodo UI."""
        if msg.data:
            self.doHoming()
    
    def ui_estop_callback(self, msg: Bool):
        """Procesa comando de parada de emergencia desde el nodo UI."""
        if msg.data:
            self.trigger_emergency_stop()
        else:
            self.release_emergency_stop()
    
    def ui_csv_callback(self, msg: String):
        """Procesa comando de cargar CSV desde el nodo UI."""
        filepath = msg.data
        success, message = self.load_trajectory_from_csv(filepath)
        if success:
            self.execute_trajectory()
    
    def ui_request_angles_callback(self, msg: Bool):
        """Procesa solicitud de ángulos actuales desde el nodo UI."""
        if msg.data:
            self.doRequestCurrentAngles()

    # def invKin_callback(self):
    #     # Usado en callback de timer [TEST]
    #     self.doInvKin(self.x, self.y, self.z)
    #     # Actualizo valores de ejemplo
    #     self.x += 0.1
    #     self.y += 0.1
    #     self.z += 0.1

    def cmd_callback(self):
        """Callback periodico para publicar comandos (solo se ejecuta sin UI)."""
        if not self.emergency_stop:
            self.doCmd(self.q1, self.q2, self.q3)
        else:
            self.get_logger().warn('E-Stop activado: Comando bloqueado')
    
    def trigger_emergency_stop(self):
        """Activa la parada de emergencia."""
        self.emergency_stop = True
        estop_msg = Bool()
        estop_msg.data = True
        self.estop_publisher_.publish(estop_msg)
        self.get_logger().critical('EMERGENCY STOP ACTIVADO')
    
    def release_emergency_stop(self):
        """Desactiva la parada de emergencia."""
        self.emergency_stop = False
        estop_msg = Bool()
        estop_msg.data = False
        self.estop_publisher_.publish(estop_msg)
        self.get_logger().info('Emergency stop desactivado')
    
    def load_trajectory_from_csv(self, filepath: str) -> tuple:
        """Carga una trayectoria desde un archivo CSV."""
        success, message = self.trajectory_reader.read_file(filepath, has_header=False)
        if success:
            self.get_logger().info(f'Trayectoria cargada: {message}')
        else:
            self.get_logger().error(f'Error cargando trayectoria: {message}')
        return success, message
    
    def execute_trajectory(self, delay: float = 0.1):
        """Ejecuta la trayectoria cargada."""
        trajectory = self.trajectory_reader.get_trajectory()
        if not trajectory:
            self.get_logger().warn('No hay trayectoria cargada')
            return
        
        self.get_logger().info(f'Ejecutando trayectoria con {len(trajectory)} puntos')
        
        for point in trajectory:
            if self.emergency_stop:
                self.get_logger().warn('E-Stop activado: Trayectoria interrumpida')
                break
            
            if point.is_cartesian():
                # Use Cartesian coordinates (x, y, z) directly
                self.doInvKin(point.x, point.y, point.z)
            elif point.is_joint():
                # Use joint coordinates (q1, q2, q3)
                self.doCmd(point.q1, point.q2, point.q3)
            
            time.sleep(delay)


def main(args=None):
    rclpy.init(args=args)

    minimal_publisher = MinimalPublisher()

    rclpy.spin(minimal_publisher)

    # Destroy the node explicitly
    # (optional - otherwise it will be done automatically
    # when the garbage collector destroys the node object)
    minimal_publisher.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
